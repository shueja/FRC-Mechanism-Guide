{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"FRC Software Mechanism Design Patterns","text":"<p>These guides are for FRC programmers tasked with creating a subsystem for a particular kind of mechanism. FRC mechanisms fall into a few common categories, and this site captures techniques and general advice for each category. </p> <p>These guides are highly opinionated and based on team 6995 NOMAD's 2025 season codebase and prior experience. However, parts of the guides are still helpful under other software architectures.</p> <p>The guides assume:</p> <ul> <li>Java command-based architecture</li> <li>Use of command factory methods in subsystems and for compositions (see general command advice)</li> <li>Every mechanism is driven by a TalonFX with Phoenix 6<ul> <li>TalonFXS is largely the same, but the author does not have experience with TalonFXS and its need for an external encoder. </li> </ul> </li> <li>Pneumatics are not included </li> </ul>"},{"location":"#how-to-use-this-guide","title":"How to Use this Guide","text":"<ol> <li>Each guide page has several categories of advice; see here for an explanation of each category.</li> <li>Start by reading the general advice that applies to any kind of motorized subsystem.</li> <li>Read the page specific to your category of mechanism below.</li> </ol>"},{"location":"#guides-for-mechanism-types","title":"Guides for Mechanism Types","text":"<p>How Each Guide is Structured</p> <ul> <li> <p>General</p> <p>Advice applicable to all motorized subsystems.</p> </li> <li> <p>Rollers</p> <p>Any mechanism that spins at a non-precise speed, with no hard limits to its range of motion.</p> </li> <li> <p>Manual or End-to-End Position Mechanisms</p> <p>Position control by manual (joystick/button) input or driving to a hard stop.</p> </li> <li> <p>Elevators</p> <p>Feedback-controlled linear position, with or without gravity compensation.</p> </li> <li> <p>Pivots</p> <p>Arms, Wrists, Turrets, Swerve Steering, with or without gravity compensation.</p> </li> <li> <p>Flywheels</p> <p>Usually in shooting games, using feedback to get consistent wheel speed. Also Swerve Drive motors.</p> </li> <li> <p>Swerve</p> <p>Suggestions for building on the CTRE swerve library.</p> </li> </ul>"},{"location":"#what-this-is-not","title":"What This Is Not","text":"<p>This is not a substitute for basic Java tutorials, WPILib documentation, or motor vendor documentation. This content assumes a basic familiarity with Java, the command-based architecture, and the various control strategies, configuration options, and feedback provided in the Phoenix 6 TalonFX library.</p> <p>The content on this site is the opinion of the author and is not official training material of 6995 NOMAD, nor does it necessarily represent 6995's continued practices.</p>"},{"location":"mechanisms/elevators/","title":"Elevators","text":""},{"location":"mechanisms/elevators/#simulation","title":"Simulation","text":"<p>TODO ElevatorSim example</p>"},{"location":"mechanisms/general/","title":"General Mechanism","text":"<p>This section describes aspects that should be common across most mechanisms.</p> Conventions Commands Control Configuration Constants Telemetry Feedback Simulation Tuning"},{"location":"mechanisms/pivots/","title":"Pivots","text":""},{"location":"mechanisms/pivots/#simulation","title":"Simulation","text":"<p>TODO SingleJointedArmSim example</p>"},{"location":"mechanisms/rollers/","title":"Rollers","text":"<p>This guide is for rollers or wheels that spin freely (no hard stops) but often push or stall against game pieces or field elements. </p>"},{"location":"mechanisms/rollers/#conventions","title":"Conventions","text":"<p>It is important to be consistent regarding which direction is positive. However, best architecture abstracts positive or negative output as task-specific commands (see next section).</p> <p>CONVENTION (suggestion)</p> <p>Generally, positive input should bring the piece into the robot/towards the scoring mechanism. Even if scoring involves feeding the piece out, opposite the direction it came in, scoring should then be negative input.</p>"},{"location":"mechanisms/rollers/#commands","title":"Commands","text":"<pre><code>/**\n * This is private because it shouldn't be accessed outside the subsystem\n * when not within a Command.\n */\nprivate void setVoltage(double voltage) {\n    motor.setControl(voltageRequest.withOutput(voltage));\n}\n\n/**\n * This is the core command. It runs indefinitely and sets the motor voltage every loop.\n * Other commands can be written using this one.\n * This is for if the voltage is not known until the command is run, or\n * if the voltage changes during the command.\n */\npublic Command voltage(DoubleSupplier voltage) {\n    return run(()-&gt;setVoltage(voltage.getAsDouble())).withName(\"voltage\");\n}\n\n/**\n * If the voltage is constant, the control request does not need to be updated\n * every loop. But this command should still run until interrupted, mirroring\n * how the motor will continue running the request. Otherwise, the default command\n * could take over.\n */\npublic Command voltage(double voltage) {\n    return startRun(()-&gt;setVoltage(voltage), ()-&gt;{}).withName(\"voltage(\" + voltage + \")\");\n}\n\n/**\n * This is the **default command**. It runs until interrupted.\n */\npublic Command stop() {\n    return voltage(0).withName(\"stop\");\n}\n\n/**\n * This variant is useful in compositions. It stops the motor and ends immediately. \n * \n * If it is within a sequence group, the group can move immediately on.\n * If it is within a parallel group, the group ends after the other commands\n * in the group end.\n * If it is run on its own, it ends immediately and the subsystem goes to\n * default command, which is also a stop command.\n */\npublic Command stopOnce() {\n    return runOnce(()-&gt;setVoltage(0)).withName(\"stopOnce\");\n}\n</code></pre> <p>Other commands should describe tasks specific to the mechanism's role. For example:</p> <ul> <li>Consider a \"midtake\", which receives and holds a game piece from an intake, but also feeds that game piece to a shooter. It might have:<ul> <li><code>intake()</code>, a fast roller speed matching the incoming game piece,</li> <li><code>store()</code>, a slower speed which is used with sensors to put the game piece in a specific position in the midtake,</li> <li><code>feed()</code>, a different speed which pushes the game piece to the shooter</li> </ul> </li> <li>Task-specific naming is better than e.g. <code>fast()</code>, <code>slow()</code> because it allows others writing robot code to understand which action should be used.</li> <li>Sometimes the task-specific outputs might be defined outside the roller subsystem.</li> </ul> <p>EXAMPLE</p> <p>6995's 2025 code had 6 different ways to score the same game piece (coral). Each scoring option had its own scoring voltage for the \"hand\" subsystem (not all in the same direction), which was encoded alongside other option-specific configuration. Thus, the scoring command looked something like <code>hand.voltage(()-&gt;scoringOption.scoreVolts)</code>. This is fine, because the command's role is still self-documenting.</p>"},{"location":"mechanisms/rollers/#control","title":"Control","text":"<p>Use a <code>VoltageOut</code> request.</p>"},{"location":"mechanisms/rollers/#configuration","title":"Configuration","text":""},{"location":"mechanisms/rollers/#current-limits","title":"Current Limits","text":"<p>Current limits are the most important configuration. The stator current limit roughly corresponds to maximum applied torque on the roller. </p> <p>Be sure to actually enable the current limit: <code>.withStatorCurrentLimitEnable(true)</code>. If you are not simulating motor velocity, enable the limit only in real life, with <code>.withStatorCurrentLimitEnable(RobotBase.isReal())</code>.</p> <ul> <li>If the roller needs to stall against a piece continuously, such as to hold a compressible ball, the current limit might need to be high in order to get a solid grip.</li> <li>A too-high limit can let the roller break friction and slip past the piece. This may or may not be wanted.</li> <li>A too-high limit could also cause mechanical failure if the weak link is a belt run instead of friction against the piece.</li> <li>A too-low current limit can show as the roller stopping as soon as it touches a game piece (i.e. any more resistance than just free spinning). </li> </ul>"},{"location":"mechanisms/rollers/#inversion","title":"Inversion","text":"<p>Configure the InvertedValue so that positive input obeys the convention described above.</p>"},{"location":"mechanisms/rollers/#neutralmode","title":"NeutralMode","text":"<p>Usually <code>Brake</code> for consistency of stopping position, but if the rollers need to free-spin, <code>Coast</code> can be used.</p> <p>EXAMPLE</p> <p>In 6995's 2024 robot, the intake pivoted down and passed the game piece (a foam torus) through to a midtake roller. Sometimes the intake would automatically pivot up and stop before the piece was fully out of the intake, so the piece would be bent and get stuck. Perhaps <code>Coast</code> mode on the intake rollers would have permitted the midtake rollers to still pull the piece out of the intake.</p>"},{"location":"mechanisms/rollers/#constants","title":"Constants","text":"<p>It may make sense to store the voltage for each task as a constant, but if the constant is only used in a command factory like <pre><code>public Command intake() {\n    return voltage(Constants.INTAKE_VOLTAGE);\n}\n</code></pre> then it becomes redundant. The voltage value can be written directly and still be self-documenting:</p> <pre><code>public Command intake() {\n    return voltage(4);\n}\n</code></pre>"},{"location":"mechanisms/rollers/#logging","title":"Logging","text":"<p>Logging motor voltage (<code>motor.getMotorVoltage()</code>) and stator current (<code>motor.getStatorCurrent()</code>), as well as motor velocity (<code>motor.getVelocity()</code>) are useful for understanding what the roller was doing in replay, since rollers are otherwise hard to visualize. The exact value of velocity does not matter, but it helps capture what the roller was actually doing when given a particular voltage.</p>"},{"location":"mechanisms/rollers/#simulation","title":"Simulation","text":"<p>Simulation is not necessary for pure voltage control, if the current limit is disabled in simulation. </p> <p>If the position of the roller becomes needed for visualization, robot behavior, or simulating other sensors, then a <code>DCMotorSim</code> can be used.</p>"},{"location":"mechanisms/rollers/#tuning","title":"Tuning","text":"<p>The primary things to tune are the inversion configuration, the current limit, and the voltages needed for varying tasks, in that order.</p>"},{"location":"mechanisms/structure/","title":"How to Read This Guide","text":"<p>Each mechanism's page has several sections:</p>"},{"location":"mechanisms/structure/#conventions","title":"Conventions","text":"<p>Consistency is key to ease of integration, collaboration, and modification. This section will describe the relevant conventions used by the software tools available (WPILib, Phoenix 6). These conventions define what direction is positive and what the zero point is for measuring the mechanism. For best experience, your code should align with those tools.</p>"},{"location":"mechanisms/structure/#commands","title":"Commands","text":"<p>Suggests the externally accessible options for interacting with the mechanism. These take the form of <code>public</code> methods in the subsystem which return simple <code>Command</code>s that require the subsystem. By exposing these commands, the subsystem developer gives other developers a clear definition of and safe access to the subsystem's capabilities.</p>"},{"location":"mechanisms/structure/#control","title":"Control","text":"<p>Details how the commands can be implemented with Phoenix 6 <code>ControlRequest</code>s.</p>"},{"location":"mechanisms/structure/#configuration","title":"Configuration","text":"<p>Details elements of motor configuration which are important for each use case.</p>"},{"location":"mechanisms/structure/#constants","title":"Constants","text":"<p>Suggests ways to organize constants such as the physical properties of the mechanism or important output values that need names.</p>"},{"location":"mechanisms/structure/#logging","title":"Logging","text":"<p>Suggests feedback from the motor or other sources that would be useful to log or broadcast for telemetry. </p>"},{"location":"mechanisms/structure/#feedback","title":"Feedback","text":"<p>Suggests feedback from the motor or other sources that is useful for automation.</p>"},{"location":"mechanisms/structure/#simulation","title":"Simulation","text":"<p>Suggests what parts of the physics of the mechanism are worth modeling and how, and what parts aren't likely to be useful given the use case of simulation.</p>"},{"location":"mechanisms/structure/#tuning","title":"Tuning","text":"<p>Suggests a process for tuning the software, starting from the first time the hardware is available. This includes checks to do before even enabling, in order to minimize risk of easily-catchable errors leading to mechanism damage.</p>"},{"location":"mechanisms/general/commands/","title":"Commands","text":"<p>These guides use the Subsystem Command Factory architecture within the WPILib command-based framework. This is recommended by the designers of the command framework for several reasons:</p>"},{"location":"mechanisms/general/commands/#architecture-goals","title":"Architecture Goals","text":"<ol> <li>Command-based programming is designed to prevent hardware (such as motors) from receiving and trying to follow two conflicting instructions at the same time. </li> <li>To best enforce this practice, a subsystem should make it impossible for code outside the subsystem to control the hardware outside of a command that requires the subsystem.</li> <li>Commands representing the most basic subsystem actions usually only need one or two of the command lifecycle stages (initialize, execute, isFinished, end)</li> <li>It is helpful to be able to tell what basic commands a subsystem can perform from within an autocomplete list.</li> <li>As required by the command scheduler, a single instance of a command should not be used in more than one composition. The architecture should make it easy to get a new instance of a given command each time the command is needed.</li> </ol>"},{"location":"mechanisms/general/commands/#subsystem-command-factory","title":"Subsystem Command Factory","text":"<ul> <li>The subsystem's only public methods for performing actions are Command Factories.<ul> <li>These methods are usually called during code setup, for example when binding buttons or constructing autonomous routines.</li> <li>The methods take some parameters and return Commands requiring the subsystem (and no other subsystems)</li> <li>Every time the factory method is run, it constructs and returns a new Command instance.</li> </ul> </li> <li>The subsystem can and should still have non-controlling methods that expose feedback about the subsystem's state, such as <code>getPosition()</code> or <code>boolean isAtTarget(double target)</code>.</li> <li>Private methods that directly control hardware are a normal implementation detail, but they must be private so they cannot be used from outside the subsystem.</li> </ul>"},{"location":"mechanisms/general/commands/#implementation-techniques","title":"Implementation Techniques","text":"<p>The code example below uses several techniques designed to help implement this architecture.</p> <ul> <li>Use of <code>Subsystem.run()/runOnce()/startEnd()/startRun()</code> to easily wrap a private subsystem method into a command which automatically requires the subsystem.<ul> <li>For clarity, the example here calls these as <code>this.run(...)</code> etc, but simply calling <code>run(...)</code> in a subsystem has the same effect.</li> </ul> </li> <li>Use of command decorators such as <code>until(BooleanSupplier condition)</code> and the inline commands in <code>edu.wpi.first.wpilibj2.command.Commands</code>.</li> <li>Exposing boolean-returning methods as <code>Trigger</code>s for convenient combination with other conditions.</li> <li>Method reference syntax <code>object::method</code> as a shorthand for <code>()-&gt;{return object.method();}</code> </li> </ul>"},{"location":"mechanisms/general/commands/#subsystem-example","title":"Subsystem Example","text":"<p>This example is of a conveyor with a game piece detection sensor, such as a beam break. This would be classed as a \"roller\" subsystem. See the Rollers guide for details on implementing subsystems like this.</p> <pre><code>// for sequence(), etc\nimport static edu.wpi.first.wpilibj2.command.Commands.*; \npublic class Conveyor extends SubsystemBase {\n    public Conveyor() {...}\n\n    /**\n     * Suppose the sensor needs some debouncing; this can be done easily when\n     * using a Trigger\n     */\n    public final Trigger pieceDetected =\n        new Trigger(()-&gt;{/*beam broken*/}).debounce(0.1);\n\n    /**\n     * This method would be called each loop, so the parameter is not a Supplier.\n     * It is private, according to the architecture.\n     */\n    private void setVoltage(double volts) {...}\n\n    public Command voltage(double volts) {...}\n\n    /**\n     * This matches the speed the piece would have entering the conveyor.\n     */\n    public Command receive() {\n        return voltage(10).withName(\"receive\");\n    }\n\n    public Command stopOnce() {\n        return this.runOnce(()-&gt;setVoltage(0));\n    }\n\n    /**\n     * Even complex commands can be defined inside the subsystem.\n     * This one tries to move the conveyor so the piece is barely forward enough to break the beam.\n     * It assumes the piece is either currently breaking the beam, behind the beam, or not yet in the conveyor.\n     */\n    public Command storePiece() {\n        return sequence( // imported from Commands.*\n            // Run quickly forward until the piece is detected.\n            receive().until(pieceDetected)\n            // if piece is detected when storePiece starts, skip the receive\n                .unless(pieceDetected),\n            // reverse slowly until no longer detecting\n            voltage(-0.5).until(pieceDetected.negate()),\n            //The piece is now behind the beam, not breaking it.\n            //Move forward slowly to position it precisely, barely breaking the beam.\n            voltage(0.2).until(pieceDetected),\n            stopOnce()\n        ).withName(\"storePiece\");\n    }\n}\n\n// Outside the subsystem\nvoid bindTriggers() {\n    Trigger intakeButton = controller.a();\n    // Command factories should be called during code setup, not when trying to run the command.\n    intakeButton.onTrue(intake.intake()).onTrue(conveyor.storePiece());\n    // Using the Trigger outside the subsystem.\n    conveyor.pieceDetected.whileTrue(/*driver feedback*/);\n}\n</code></pre>"},{"location":"mechanisms/general/commands/#alternative-command-architectures","title":"Alternative Command Architectures","text":""},{"location":"mechanisms/general/commands/#problems-with-subsystem-command-factories","title":"Problems with Subsystem Command Factories","text":"<p>The above architecture does have some downsides:</p> <ul> <li>Sometimes a subsystem has so many command factories or factories with enough complexity that it becomes hard to navigate or find the internal implementation of the subsystem. </li> <li>When creating a command that only requires one subsystem but needs information from another (such as if <code>pieceDetected</code> was not within the <code>Conveyor</code> class), a subsystem command factory needs to have that information passed in as a parameter. This is known as dependency injection (DI). Alternatively, the command factory can be written somewhere where both subsystems can be injected or are already in scope.  </li> <li>Factories creating multi-subsystem compositions have the same issues regarding DI, and really shouldn't be in any one subsystem. Writing full compositions as-needed (i.e. within a button binding) works but makes it hard to reuse work, such as between teleop bindings and auto routines.</li> </ul> <p>Below are a few other common ways to organize the definitions of commands.</p>"},{"location":"mechanisms/general/commands/#separate-factory-classes","title":"Separate Factory Classes","text":"<p>Writing non-subsystem classes containing multi-subsystem factories is a great way to organize the robot's higher-level subsystem integration. There are generally two ways to do this.</p> <ol> <li>Take an instance of each subsystem in the class constructor and access the class's member variables in the subsystems. This is less boilerplate and leads to compositions looking similar between the factory class and <code>Robot.java</code>.</li> <li>Take an instance of each needed subsystem in each factory's parameter list, so that the factories can be static. This is more typing when calling each factory, but makes it easier to spread factory methods out wherever they make sense to write. </li> </ol>"},{"location":"mechanisms/general/commands/#class-commands","title":"Class Commands","text":"<p>WPILib does support writing full subclasses of <code>Command</code> to define command behavior. This is not generally recommended because most subsystem behavior can be expressed more succinctly with compositions of factory methods. However, class commands have some benefits:</p> <ul> <li>They can easily store state that might need to be captured on <code>initialize</code>, during some <code>execute</code>s, etc.</li> <li>When the command has many parameters or different possible constructors, it can help to write them as class constructors rather than factory methods within the subsystem. </li> <li>If all four lifecycle methods have complicated bodies that aren't used in other commands or exposed in the subsystem, a class command can contain those long methods.</li> </ul> <p>When using class commands, ensure the following:</p> <ol> <li>You MUST call <code>addRequirements(Subsystem...)</code> in the constructor with any subsystems required by the command. The automatic requirement implicit in the <code>Subsystem#run()</code> etc. factories is not available here.</li> <li>You are not creating and scheduling other, more simple subsystem commands. This will cause the class command to be interrupted.</li> </ol>"},{"location":"mechanisms/general/commands/#package-private-preserving-access-safety-outside-subsystems","title":"Package-Private: Preserving Access Safety Outside Subsystems","text":"<p>When defining commands outside the subsystem which directly call the hardware-controlling methods, the prior advice of making the hardware-controlling methods private does not work. However, Java has the concept of package-private methods, which uses the package layout (defined by the directory layout) to restrict access.</p> <p>Consider the following directory layout: <pre><code>robot\n| subsystems\n| | conveyor\n| | | Conveyor.java (frc.robot.subsystems.conveyor.Conveyor)\n| | |_ReceiveCommand.java (frc.robot.subsystems.conveyor.ReceiveCommand)\n| |_MultiSubsystemFactories.java (frc.robot.subsystems.MultiSubsystemFactories)\n|_Robot.java (frc.robot.Robot)\n</code></pre></p> <p><code>Conveyor</code> has a package-private <code>setVoltage</code> method, declared by the lack of another access modifier:</p> <pre><code>public class Conveyor extends SubsystemBase {\n    void setVoltage(...){...}\n}\n</code></pre> <p>If <code>ReceiveCommand</code> can access an instance of <code>Conveyor</code>, it can call the package-private <code>setVoltage</code>: <pre><code>public class ReceiveCommand extends CommandBase {\n    private Conveyor conveyor;\n    public ReceiveCommand(Conveyor conveyor) {\n        this.conveyor = conveyor;\n    }\n    @Override\n    public void initialize() {\n        conveyor.setVoltage(10);\n    }\n}\n</code></pre></p> <p>But <code>Robot</code> cannot call <code>setVoltage</code> because <code>frc.robot.Robot</code> is not in the same package as <code>frc.robot.subsystems.conveyor.Conveyor</code>:</p> <pre><code>public class Robot extends TimedRobot {\n    private Conveyor conveyor = new Conveyor();\n    void teleopPeriodic() {\n        conveyor.setVoltage(10); // This ERRORS, as it should.\n    }\n}\n</code></pre>"},{"location":"mechanisms/general/control/","title":"Control Requests","text":"<p>This section  Reference the [Phoenix 6 docs] (https://v6.docs.ctr-electronics.com/en/stable/docs/api-reference/device-specific/talonfx/closed-loop-requests.html) on closed-loop control.</p>"},{"location":"mechanisms/general/control/#feedforward-on-rio-vs-on-talon","title":"Feedforward: On-RIO vs On-Talon","text":"<p>The TalonFX has </p>"},{"location":"mechanisms/general/conventions/","title":"Conventions","text":"<p>This section describes measurement conventions used by WPILib and other tools. It also includes other conventions to adopt to make life easier.</p>"},{"location":"mechanisms/general/conventions/#coordinate-system","title":"Coordinate System","text":"<p>Reference the WPILib article on coordinate systems.</p> <p>This guide recommends the Always Blue Origin field coordinate system, and Phoenix swerve's <code>FieldCentric</code> request has the ability to invert controls as described in the WPILib docs.</p>"},{"location":"mechanisms/general/conventions/#robot-front-side","title":"Robot Front Side","text":"<p>Early in robot development, the front of the robot must be defined. For swerve drive under field-oriented control, the choice of front does not affect the way the robot drives. Here are some associated conventions and common calculations to consider.</p> <ul> <li>Pivoting mechanisms generally use a 0 point of horizontal, pointing out the front of the robot.</li> <li>If a scoring mechanism needs to point towards a location on the field, having the front be the scoring mechanism side makes the robot face towards the target instead of directly away from it.</li> <li>If using robot-relative control for some things, let the driver decide which way forward is, even if the rest of the code uses a different side as front.</li> </ul>"},{"location":"mechanisms/general/conventions/#units","title":"Units","text":"<p>WPILib uses meters and radians as the default units for geometry, as it does with most of its math and simulation tooling. For best results, work with distances in a base unit of meters and field angles (such as the heading of the robot or other field positions) in radians.</p> <p>CTRE Phoenix 6 supports the WPILib Java Units API for configuration. The feedforward/feedback gains and the position/velocity etc reporting is designed to work in mechanism rotations, so the <code>SensorToMechanismRatio</code> must be configured correctly. Simulation states work in raw motor rotations, so some unit conversions are required when plumbing simulation. </p> <p>For linear mechanisms like elevators, this guide recommends leaving SensorToMechanismRatio as 1 and converting setpoints and feedback between motor rotations and meters in the subsystem. Unfortunately, Phoenix 6's API cannot map motor motion to distance traveled except by pretending one mechanism rotation equals one distance unit (meter).</p>"},{"location":"mechanisms/general/conventions/#motor","title":"Motor","text":"<p>Motors should always be configured so that a positive command causes position feedback to increase and velocity feedback to be positive. Conventions for which mechanism direction is positive are in the individual mechanism guides. Brushless motors do this automatically for built-in encoders, but external encoders, especially those not on the motor shaft, need to be checked for proper inversion relative to the motor.</p>"},{"location":"mechanisms/general/simulation/","title":"Simulation","text":"<p>Reference the Phoenix 6 simulation docs</p>"},{"location":"mechanisms/general/simulation/#goals-of-the-simulation-guide","title":"Goals of the Simulation Guide","text":"<p>For most teams, simulation only needs to be accurate enough to test subsystem integration logic. This guide will focus on setting up physics models to give subsystems realistic responses. The guide is relatively Phoenix 6 specific because Phoenix 6 simulates the entire motor controller.</p>"},{"location":"mechanisms/general/simulation/#non-goals-of-the-simulation-guide","title":"Non-Goals of the Simulation Guide","text":"<p>This guide does not cover replay, in which logged values are fed back into the robot program. For log replay, the most popular option is AdvantageKit. Its docs explain where replay is useful and how the ability to replay limits code architecture. Without replay, a TalonFX-driven subsystem can have simulation added without having to abstract the hardware access into a real and simulation version.</p>"},{"location":"mechanisms/general/simulation/#data-flow-of-simulation","title":"Data Flow of Simulation","text":"<p>Consider a position-based subsystem which controls and gets feedback from a motor:</p> <p><pre><code>public class PositionSubsystem extends SubsystemBase {\n    TalonFX motor = ...;\n\n    /** Requests on-motor-controller feedback*/\n    private void goToPosition(double position) {...}\n    public double getPosition() {...}\n}\n</code></pre> Consider the real-life cycle of information in this subsystem. 1. <code>goToPosition</code> sends a setpoint to the motor controller, 2. which executes a control loop based on the current position. 3. As the motor applies torque, the physical robot moves in a predictable way. 4. The motor measures the position as it changes using the encoder. 5. The position is used in the motor's control loop and also sent back to the robot code.</p> <p>How can this process be run without real hardware? If the program running on the motor controller is simulated accurately, as Phoenix 6 is designed to do, then only step 3 needs to be different between simulation and real-life.</p> <p>Note that step 3 assumes the robot moves in a predictable way. Based on measured physical properties of the mechanism or the motor's own tuned feedforward constants (<code>kS</code>, <code>kV</code>, <code>kA</code>, and <code>kG</code> where applicable), we can write calculations which model the next mechanism state (such as position and velocity) given the current state and the voltage input. This is the core of physics simulation: reading what the motor would be doing, calculating its effect, and telling the (simulated) motor controller what actually happened.</p> <p>TERMINOLOGY</p> <ul> <li>The state in FRC usage usually consists of both the position and velocity of the mechanism. Some WPILib simulation classes use a state that is just velocity.</li> <li>The input is the voltage exerted by the motor. This is an \"output\" of the robot code, but an input to the physics-modeling equations.</li> <li>The model is the set of equations that describe the next state in terms of the current state and input.</li> </ul>"},{"location":"mechanisms/general/simulation/#implementation","title":"Implementation","text":"<p>Where should the simulation code go?</p> <p>Logically, the code that simulates reality should be separate from the rest of your robot code. It should only interface with the subsystem code through information read from and provided to the motor controller. Some uses of simulation in industry have the simulation code in an entirely separate program, created with tools designed to model physical systems.</p> <p>However, in FRC usage, the simulation still needs to access the motor class, be set up using the subsystem's constants, and run in the periodic loop during simulation. For ease of development, simulation code can just go in the subsystem's <code>simulationPeriodic</code> method.</p>"},{"location":"mechanisms/general/simulation/#physical-properties-or-feedforward-constants","title":"Physical Properties or Feedforward Constants?","text":"<p>The subsystem should have a sim object within it, which is constructed using physical properties or feedforward constants and keeps track of the simulated system state. While constructing with physical properties such as mass, inertia, and gear ratio may seem appealing, especially before the hardware is available, keep in mind that after tuning the mechanism, feedforward constants will give a much more accurate model of the system than estimated physical properties. For early development, the mechanism calculator Recalc can convert estimated physical properties to theoretical <code>kV</code> and <code>kA</code>.</p>"},{"location":"mechanisms/general/simulation/#the-sim-model-class","title":"The Sim Model Class","text":"<p>These sim objects can also model hard range limits and account for gear ratios. WPILib provides several sim objects for common use cases. They differ in the units used for configuration and output:</p> Class State Units Notes Usage DCMotorSim Position, Velocity Motor Rotations No range limits Rollers, Flywheels ElevatorSim Position, Velocity Meters Range limits, gravity modeling (assumes vertical elevator) Elevators, range-limited linear motion SingleJointedArmSim Position, Velocity Radians Range limits, gravity modeling (assumes 0 is arm horizontal) Arms, wrists, pivoting intakes, range-limited angular motion"},{"location":"mechanisms/general/simulation/#dcmotorsim-code-example","title":"DCMotorSim Code Example","text":"<p>This example shows how simulation can be plumbed and how the same constants can be used in motor controller feedforward and in simulation setup. This example can be used for rollers or flywheels.</p> <p><code>ElevatorSim</code> and <code>SingleJointedArmSim</code> have different constructors and interfaces. See the simulation examples in Elevators and Pivots.</p> <p>The motor is assumed to have its SensorToMechanismRatio (and RotorToSensorRatio for external feedback) set so that gains and feedback are in mechanism rotations.  ```java // TalonFX configs, probably not stored in the subsystem directly // motor rotations per mechanism rotation, &gt;1 for reductions private final double GEARING =     config.Feedback.SensorToMechanismRatio * config.Feedback.RotorToSensorRatio; private final Slot0Configs gains = ...</p> <p>// Gains need to be converted from mechanism rotations to motor radians // Vs/(mechanism rotations) / (gearing * 2pi) = Vs^2/(motor radians) private final DCMotorSim motorSim =     new DCMotorSim(         LinearSystemId.createDCMotorSystem(             gains.kV / (GEARING * 2 * Math.PI),             gains.kA / (GEARING * 2 * Math.PI)),         DCMotor.getKrakenX60(1));</p> <p>public void simulationPeriodic() { // Get the SimState object var simState = motor.getSimState(); // Modeling voltage dips is generally overkill for testing integration simState.setSupplyVoltage(12); // simState.getMotorVoltage is counterclockwise negative double volts = simState.getMotorVoltage(); // Subtract out the kS term, since DCMotorSim doesn't include it in the model. if (Math.abs(voltage) &lt;= gains.kS) {     volts = 0; } else {     volts -= Math.copySign(gains.kS, volts); } motorSim.setInput(volts); // Calculate one loop time into the future. motorSim.update(0.02); var rotorPos = motorSim.getAngularPositionRotations(); var rotorVel = motorSim.getAngularVelocityRPM() / 60.0;</p> <p>simState.setRawRotorPosition(rotorPos); simState.setRotorVelocity(rotorVel); }</p>"}]}